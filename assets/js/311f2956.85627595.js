"use strict";(self.webpackChunkcodecharacter_docs_2022=self.webpackChunkcodecharacter_docs_2022||[]).push([[614],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return h}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(r),h=o,f=d["".concat(c,".").concat(h)]||d[h]||p[h]||a;return r?n.createElement(f,s(s({ref:t},u),{},{components:r})):n.createElement(f,s({ref:t},u))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},2255:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},assets:function(){return u},toc:function(){return p},default:function(){return h}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),s=["components"],i={sidebar_position:1},c="Rules",l={unversionedId:"Rules/Rules",id:"Rules/Rules",title:"Rules",description:"The base map is a 64x64 square grid. The defender's towers cover the base map.",source:"@site/docs/Rules/Rules.md",sourceDirName:"Rules",slug:"/Rules/",permalink:"/Rules/",editUrl:"https://github.com/delta/codecharacter-docs-2022/tree/main/docs/Rules/Rules.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"OverView",permalink:"/"}},u={},p=[{value:"Units",id:"units",level:2},{value:"Troops (Attackers)",id:"troops-attackers",level:3},{value:"Towers (Defenders)",id:"towers-defenders",level:3},{value:"GOAL",id:"goal",level:2},{value:"End of Game",id:"end-of-game",level:2}],d={toc:p};function h(e){var t=e.components,r=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"rules"},"Rules"),(0,a.kt)("p",null,"The base map is a 64x64 square grid. The defender's towers cover the base map."),(0,a.kt)("h2",{id:"units"},"Units"),(0,a.kt)("p",null,"There are two types of units - troops and towers. "),(0,a.kt)("h3",{id:"troops-attackers"},"Troops (Attackers)"),(0,a.kt)("p",null,"Troops can move and attack when defenders come in their range. There are two types of troops. Each troop has its own attributes and value, you can check that in the CONSTANTS."),(0,a.kt)("p",null,"You can only spawn the troops at the outer region of the map. If you try to spawn at the invalid inner base range, you\u2019ll be penalized with the deduction of coins but the troop won't be spawned. Same if you try to spawn more than one troop at the same position in the same turn, only one troop will be spawned but the balance will be deducted for all."),(0,a.kt)("h3",{id:"towers-defenders"},"Towers (Defenders)"),(0,a.kt)("p",null,"Towers stay at their position and attack whenever there is any troop in their range. There are two types of towers. Each tower has its own attributes and value, you can check that in the CONSTANTS."),(0,a.kt)("h2",{id:"goal"},"GOAL"),(0,a.kt)("p",null,"The attacker's goal is to destroy the defender's base as much as possible using as less coins as possible. And the defender\u2019s goal is to kill the enemy attacking and save the base."),(0,a.kt)("h2",{id:"end-of-game"},"End of Game"),(0,a.kt)("p",null,"In each match, there will be two games, both players code attacking over the other player base. Considering both match destruction and coins left, each player's score is calculated, whichever player score is more wins the match. Keep in mind, the weightage for destruction percentage is more than that for coins left percentage, but in the close matches where destruction is almost in the same range the coins left will be the deciding factor. So the ultimate strategy to win is to destroy as much as you can with as fewer coins possible. "),(0,a.kt)("p",null,"Remember to properly check your code before submitting it.\nIf there\u2019s an error in the attack code while the game is running the attacker will lose the match and will be penalized for it. If the code takes too long to execute also the attcker will lose."))}h.isMDXComponent=!0}}]);